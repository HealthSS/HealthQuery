/* eslint-disable no-shadow */
import React, { useEffect, useRef } from 'react';
import { animated, useSpring, config } from 'react-spring';
import * as d3 from 'd3';
import './PieChartStyles.css';

//* The argument for scaleOrdinal could alternatively be an array of colors ie ["#1f77b4", "#ff7f0e", "#2ca02c"]
//* This method returns a function that will always return the same value from the array for any given argument.
//* It will loop through in order and return the next value in the array if the input is different.
const colors = d3.scaleOrdinal(d3.schemeCategory10);
//* Rounds numbers. This formats the numbers seen on the pie chart.
const format = d3.format('.1f');

//* This functional component becomes a child of the parent AnimatedPie component
// eslint-disable-next-line no-unused-vars
const Arc = ({ index, from, to, createArc, colors, format, springProps }) => {
  //* The method returned by interpolate takes an argument of any number between 0 and 1; it then returns the interpolated value.
  const interpolator = d3.interpolate(from, to);

  return (
    <g>
      {/* Note that a className can be added to this or any other SVG element */}
      {/* 'animated' is a react-spring factory that includes all native elements including the SVG path element */}
      <animated.path
        //* The 'd' attribute is the path to be drawn
        d={springProps.t.interpolate(t =>
          //* t moves between 0 and 1 here
          //* The return value of createArc is the path.
          //* This is generated by interpolating the from/to data which includes the properties needed by the createArc method: index, value, startAngle, endAngle, padAngle
          createArc(interpolator(t))
        )}
        //* The format of the return value of colors is "#1f77b4"
        fill={colors(index)}
      />
      <animated.text
        //* createArc computes the midpoint of the center line of the arc the arc generated by the same data that generates the arc itself.
        //* We perform a translate transformation to move this SVG text element to the proper position.
        transform={springProps.t.interpolate(
          t => `translate(${createArc.centroid(interpolator(t))})`
        )}
        //* Centers the text horizontally
        textAnchor="middle"
        //* Centers the text vertically
        alignmentBaseline="middle"
        //* Text color
        fill="white"
        fontSize="18"
        fontWeight="bold"
      >
        {springProps.t.interpolate(
          t =>
            // format(interpolator(t).value)
            Math.round(interpolator(t).value),
          0
        )}
      </animated.text>
    </g>
  );
};

const AnimatedPie = ({
  innerRadius,
  outerRadius,
  data,
  width,
  height,
  title
}) => {
  //* Cache is an object with an empty array as the value of the current key
  const cache = useRef([]);
  const createPie = d3
    //* Computes the angles to convert a tabular dataset to a pie/donut chart
    .pie()
    //* dataObject.value lets d3 know where in the dataset to find the values that should be used to generate the pie chart
    .value(dataObject => dataObject.value)
    //* D3 sorts data largest to smallest by default. An argument of null maintains the order they are defined in.
    .sort(null);
  const createArc = d3
    //* Arc is used to calculate SVG paths
    .arc()
    //* Distances are in pixels
    //* Inner radius is the distance of the empty space in the center of the pie chart. 0 will create a pie chart rather than a doughnut chart.
    .innerRadius(innerRadius)
    //* Outer radius is the distance of the outer edge of the pie chart.
    .outerRadius(outerRadius);

  //* The data comes from the parent component
  //* The data is an array of objects. Each object stores the initial input data object as the value of the data key.
  //* The rest of the object includes information relevent to D3 calculations: index, value, startAngle, endAngle, padAngle
  const chartData = createPie(data);

  //* Generating previousData from what is cached allows React Spring to know what we are moving from => to
  const previousData = createPie(cache.current);

  useEffect(() => {
    //* cache.current persists as the component mounts and unmounts
    //* Every time state changes, we update cache.current with the new props (the values to be displayed)
    cache.current = chartData;
  });

  const mapLegend = chartData.map((el, index) => (
    <div
      key={el.data.city}
      className="mx-3 mapLegendStyles"
      style={{ backgroundColor: colors(index) }}
    >
      {el.data.city}
    </div>
  ));

  //! The next lines are React-Spring
  const springProperties = {
    // eslint-disable-next-line no-unused-vars
    to: async (next, cancel) => {
      await next({ t: 1 });
    },
    //* 't' moves between 0 and 1 because the interpolator method takes an argument between 0 and 1
    from: { t: 0 },
    //* Using animation duration rather than traditional spring behavior. Could customize easing as well.
    // config: { duration: 400 }, // duration-based animation
    config: config.slow,
    //* Reset the spring so that it goes: from => to
    reset: true
  };

  const [springProps, setSpringProps] = useSpring(() => springProperties);
  //* setSpringProps is an updated function. It executes the animation without causing the component to render.
  //* A stop method can be added as the third argument
  setSpringProps(springProperties);

  return (
    <div>
      <div className="row">
        <div className="col-12 d-flex justify-content-center">
          <svg className="svgShadow" width={width} height={height}>
            {/* SVG Width and Height are the dimensions of the entire SVG area */}

            {/* Centered Text Element */}
            <text
              x="50%"
              y="50%"
              textAnchor="middle"
              fontSize="30"
              fontWeight="bold"
              fill="white"
            >
              {title}
            </text>

            {/* Translate moves the circle right and down to the center of the SVG. Since they will be placed at 0,0 by default. */}
            {/* g is an svg element that groups other SVG elements. The transformation applied to this g element is applied to its children as well. That's the only reason why we need this particular g element. */}
            <g transform={`translate(${outerRadius} ${outerRadius})`}>
              {/* For each object in the data array, we create a new instance of the Arc functional component */}
              {chartData.map((data, i) => (
                <Arc
                  key={data.data.city}
                  index={i}
                  //* previousData is an array with the same structure as the data array, so to get the relevant object => we access the element at the correct index of the previousData array (rather than using the d argument)
                  from={previousData[i]}
                  to={data}
                  //* The same createArc, colors, and format methods are passed be reference to all instances of Arc
                  createArc={createArc}
                  colors={colors}
                  format={format}
                  //! React-Spring
                  springProps={springProps}
                />
              ))}
            </g>
          </svg>
        </div>
      </div>
      <div className="row mt-4">{mapLegend}</div>
    </div>
  );
};

export default AnimatedPie;
